Gérer les cas en fonction du nombre d'arguments :
- Argc = 2 : "./push_swap 1" --> Rien/
"./push_swap --bench / a / ' '" --> Error (SUR STDERROR, DONC SORTIE 2, PAS 1)/
"./push_swap "1 5 2 65 -84 98 10254 54 0"" --> Traitement

Vérifier d'abord, comme printf, si le premier caractère qui suit est "-", si c'est le cas, désigner tous les cas plausibles,
sinon --> Vérifier s'il n'y a que des nombres et appliquer l'algo adaptatif, sinon --> Error.
Possibilité de transformer le tout en "une chaine de caractère" et vérifier ensuite avec "isalpha" si la chaine entière est alphanumérique.
 
SI on utilise une liste doublement chaînée, réadapter la structure de la libft.h ainsi que toutes les fonctions de base "ft_lst..."
pour qu'elles puissent se promener plus facilement dans nos stacks.

Faire attention aux cas 3 nombres et 5 nombres --> Tri à part ?

Tri à 3 : Selon le désordre :
- 50% =
->3 - 1 - 2 (rra) --> Si (nb1 > nb2 && nb2 < nb3) --> (rra)
->1 - 2 - 3

->2 - 3 - 1 (ra) --> Si (nb1 < nb2) --> (ra)
->1 - 2 - 3

->1 - 3 - 2 (ra) --> Si (nb1 < nb2) --> (ra)
->2 - 1 - 3 (sa) 	--> Si (nb1 > nb2) --> (sa)
->1 - 2 - 3

->2 - 1 - 3 (sa) --> Si (nb1 > nb2) --> (sa)
->1 - 2 - 3

- 100% =
->3 - 2 - 1 (sa) --> Si (nb1 > nb2) --> (sa)
->2 - 3 - 1 (ra) 	--> Si (nb1 < nb2) --> (ra)
->1 - 2 - 3

Tri à 4 ou 5 : "push_to_b" valeur min --> "push_to_b" 2nde valeur min (pour 5 éléments) --> Tri de 3 éléments --> "push_to_a" x 2

Exemple : (5 - 2 - 1 - 4 - 3)

